# 共享数据结构访问/线程同步



对于32/64 bit机器，





如果写操作只需执行一条修改内存的指令就能完成对共享数据结构的修改，例如修改某些基本数据类型的变量char、short、int、指针(以arm架构为例，一条str指令就能完成对内存里面这些基本数据类型的值的修改)，则读操作**不需要**与写操作竞争锁，写操作之间**需要**竞争锁。这种情况读操作无需处理，只需在写操作之间使用互斥量来处理。如果只有一个线程进行写操作，则互斥量也可以去掉。

pthread_mutex_init

pthread_mutex_lock

pthread_mutex_unlock

pthread_mutex_destroy

mutex只有0，1两种状态。解锁的情况下再多次解锁，最后上锁时只有第一次上锁成功。









如果写操作需多条修改内存的指令才能完成对共享数据结构的修改，例如修改一个结构体或者几个变量需要同步修改，则读操作**需要**同写操作竞争锁，写操作之间**需要**竞争锁。这种情况所有读写操作之间使用读写锁来处理。即使只有一个线程写或只有一个线程读，也不能省掉读写锁，因为要处理读操作和写操作之间的竞争关系。

pthread_rwlock_init

pthread_rwlock_destroy

pthread_rwlock_rdlock

pthread_rwlock_wrlock

pthread_rwlock_unlock







# 条件量

条件量之线程同步，A线程设置x变量，B线程根据x变量是否为真来决定是否继续运行，如果x为假则B线程阻塞，当A线程让x为真时B线程继续运行，A线程通过x控制B线程的运行。A可读写x，B只读x，mutex仅用来防止：B在while满足调用pthread_cond_wait之前，A线程执行到x=1;pthread_cond_signal，此时pthread_cond_signal先于pthread_cond_wait执行，导致后面B执行pthread_cond_wait时无法解锁。

    #include<stdio.h>
    #include <unistd.h>
    #include<pthread.h>
    
    pthread_t pthread;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
    int x=0;
    
    void *pthread_fn(void *ptr)
    {
            for(;;){
                    pthread_mutex_lock(&mutex);
                    while(!x)
                            pthread_cond_wait(&cond,&mutex);
                    pthread_mutex_unlock(&mutex);
                    printf("start\n");
            }
            return NULL;
    }
    
    int main(){
            pthread_mutex_init(&mutex,NULL);
            pthread_cond_init(&cond,NULL);
            pthread_create(&pthread, NULL, pthread_fn,NULL);
            sleep(3);
    		
    		for(;;) {
    			//do something
    
                x=1;//当x从0到1时需要调用pthread_cond_signal,x从1到1时可调也可不调
                pthread_cond_signal(&cond);
                sleep(100);
    		}
        return 0;
    }




条件量  A线程生产，B线程消费，队列为空一直消费线程阻塞等待，A线程控制B     A/B都能读写队列，因此A线程操作head/tail条件时要加锁， B线程同样要在加锁环境中操作head/tail条件，此时mutex锁有两层含义，一层是保护head/tail条件共享变量的访问，另一层则负责条件量之线程同步，以免出现上面说的pthread_cond_signal先于pthread_cond_wait的情况。

```
typedef struct msg {
    struct msg * next;
    void * info;
} msg_t;

typedef struct {
    pthread_cond_t msg_cond;
    pthread_mutex_t msg_mutex;
    msg_t * head;
    msg_t * tail;
} mynet_state;

//A线程调用enqueue_msg
void enqueue_msg(mynet_state * s, msg_t * msg)
{
    msg->next = NULL;
#if 1
    pthread_mutex_lock(&s->msg_mutex);
#else
	while(pthread_mutex_trylock(&s->msg_mutex));
#endif
    if(s->tail) {
        s->tail->next = msg;
        s->tail = msg;
    } else {
        s->head = msg;
        s->tail = msg;
    }
    pthread_mutex_unlock(&s->msg_mutex);
    pthread_cond_signal(&s->msg_cond);
}

//B线程调用dequeue_msg
msg_t * dequeue_msg(mynet_state * s)
{
    msg_t * ptr;
    pthread_mutex_lock(&s->msg_mutex);
    while(s->head==NULL){
        pthread_cond_wait(&s->msg_cond,&s->msg_mutex);
    }
    ptr = s->head;
    s->head = s->head->next;
    if(s->head==NULL){
        s->tail = NULL;
    }
    pthread_mutex_unlock(&s->msg_mutex);
    return ptr;
}
```





# 自旋锁